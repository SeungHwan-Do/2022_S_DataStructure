# 동적 메모리와 전처리(Cont'd)
## 배열의 장단점
### 배열 장점
 - 첨자(index)를 사용하여 임의 참조(random access)가 가능
### 단점
- 컴파일 전에 배열의 크기가 이미 결정
- 실행 중간에 배열 크기를 늘릴 수 없는 단점
- 중간에 삽입, 삭제의 어려움
## 연결 리스트 개요
### 연결 리스트
- 원소인 노드(node)가 순차적으로 연결된 자료구조
- 자기 참조 구조체로 정의되는 노드
  <br> (자료(data)와 링크(link)로 구성)
- 헤드(head)
<br>(항상 첫 번째 노드를 가리키는 포인터)
- 테일(tail) 포인터
<br> (마지막 노드를 가리키는 포인터)
```c
노드의 구현
struct selfref {
  int n;
  struct selfref *next;
};
```
## 연결 리스트 장단점
### 장점
 -  연결 리스트는 동적으로 노드를 생성
<br>(연결 리스트의 크기의 증가 감소에 따라 효율적으로 대처 가능)
 - 노드의 삽입과 삭제로 자료의 재배치
<br> (빠르게 처리)
### 단점
 - 배열에 비하여 임의 접근(random access)에 많은 시간이 소용
<br>(연결 리스트의 노드 검색은 헤드에서부터 링크를 따라가는 순차적 검색만이 가능)
 - 구현이 배열보다 다소 어려움
## 연결 리스트 연산(1)
### 노드 순회
- 연결 리스트에서 모든 노드를 순서대로 참조하는 방법
- 링크가 NULL이면 마지막 노드
### 추가
 - 새로운 노드를 하나 생성하여 연결 리스트의 마지막 노드로 추가
## 연결 리스트 연산(2)
### 노드 삽입
 #### 기존의 연결 리스트에서 노드“C”와 노드“C++”사이에 노드 “Objective-C”를 삽입하는 과정
- 먼저 삽입 노드를 동적으로 생성하여 적당한 자료를 저장
- 삽입하려는 바로 이전 노드인 노드“C’”로 이동
<br>( 삽입하는“Objective-C”노드의 링크에 노드“C”의 링크를 저장)
- 다음에는 노드“C”의 링크를 새로 삽입하는“Objective-C”노드를 가리키도록 삽입하는“Objective-C”노드의 주소값을 저장
## 연결 리스트 연산(3)
### 노드 삭제
 #### 기존의 연결 리스트에서 노드“C++”를 삭제
- 가장 먼저 삭제하려는 노드 바로 이전 노드“C”로 이동
<br>(삭제하려는 노드“C++”를 포인터 변수에 저장)
- 노드“C”의 링크를 삭제하려는 노드“C++”의 링크 노드값으로 저장 ( 삭제할려는 노드가 가리키는 노드를 저장)
- 마지막으로 삭제 노드 “C++”를 메모리에서 제거
